Universidad de Lima Facultad de Ingeniería y Arquitectura
Carrera de Ingeniería de Sistemas




  
  



Sistema de información destinado a la gestión de reservas y estadías en un establecimiento
         Proyecto del curso Programación orientada a objetos




Abanto Lozano, Gilmer Alonso Código: 20244621
Arista Llanquecha, Piero Aarón Código: 20240249
Madalengoitia Paredes, Felipe Redfy
 Código: 20234711




Profesor
Tello  Yuen , Roberto Leonardo 




Lima – Perú Noviembre  de 2025
TABLA DE CONTENIDO
1. Resumen:        4
2. Palabras clave:        4
3. Introducción:        4
   1. Descripción de la empresa y situación        4
   2. Identificación del problema        4
   3. Objetivos        5  
   4. Metodología        5
   4. El problema:        5
   5. Objetivos SMART:        5
   1. Objetivo 1:        5
   2. Objetivo 2        6
   6. Capítulo III: Desarrollo del sistema        6
   1. Diagrama de clases        6
   2. Diagrama de casos de uso        7
   3. Pruebas de software:        9
   7. Conclusiones:        9
   8. Recomendaciones:        9
   9. Bibliografía:        10












INDICE DE FIGURAS
Figura 5.2.1. Menú principal del programa        15
Figura 5.2.2. Ingreso del número de buses y líneas        15
Figura 5.2.3. Matriz de recaudación        16
Figura 5.2.4. Bus con mayor recaudación en total de la empresa:        16
Figura 5.2.5. Línea con mayor recaudación total        16
Figura 5.2.6.Línea con menor recaudación por bus        17  
Figura 5.2.7. Orden de buses por recaudación total        17
Figura 5.2.8. Intercambio de recaudaciones entre dos buses        17
Figura 5.2.9. Mostrar matriz        18
Figura 5.2.10. Salir del programa        18
   1.         Resumen:
El presente trabajo consiste en la implementación de un sistema de administración de reserva para hoteles, aplicando los conocimientos adquiridos sobre programación con el Paradigma Orientado a Objetos.  


   2. Palabras Clave:

Programación Orientada a Objetos (P.O.O.), Software, Aplicación, Clases, Objetos, Herencia, Composición, Agregación, Polimorfismo, Empresa de hotelería, Reserva, Sistema de reserva.


      3. Introducción:
      1. Descripción de la empresa y situación


El proyecto se enfoca en empresas pequeñas y medianas de hotelería que administran sus sistemas de reserva sin utilizar software, o que utilizan software ineficiente, propenso a errores y/o vulnerabilidades.
      2. Identificación del problema


Se ha identificado patrones de errores comunes en las empresas de hotelería descritas, lo cual incluye pero no se limita a fallas como:
      * Overbooking
      * Errores en cálculos de precios según tipo de habitación y/o duración de estadía
      * etc.
        Además, las empresas desean implementar un sistema que permita la                         administración de información de facturas, reservas, habitaciones, mantenimiento, clientes y servicios adicionales
      3. Objetivos
-Desarrollar un sistema de información que permita gestionar de manera eficiente las reservas ,huéspedes ,habitaciones y servicios adicionales de un hotel.
-Implementar una solución basada en el paradigma de la Programación orientada a Objetos ,utilizando conceptos como la herencia,polimorfismo,encapsulamiento,composición,arreglos de objetos e interfaces(GUI).
-Diseñar una interfaz gráfica ,que facilite al personal del hotel realizar tareas como registrar,gestionar check in /check out y administrar datos internos.        
      4. Metodología         
Este proyecto se realizó siguiendo un proceso iterativo basado en los siguientes pasos:
Paso 1:Análisis del problema
-Revisión de los requerimientos funcionales proporcionados por el Docente.
-Identificación de las necesidades del hotel (reserva, servicios, huéspedes, habitaciones, roles del usuario, etc)
Paso 2:Identificación de objetos y clases del sistema.
-Después del análisis se listaron todas las entidades: Habitacion, Reserva, Huésped, Usuario, Administrador, Recepcionista, Servicios adicionales.
-Se clasificó en clases,atributos y métodos esenciales
Paso 3:Diseño UML del sistema
-Elaboración del diagrama de clases siguiendo relaciones de herencia, composición y asociaciones.
-Elaboración del diagrama de casos de uso definiendo actores y funciones.
Paso 4: Implementación del sistema:
-Programación de las clases en Java aplicando POO,usando el programa gitHub con un repositorio avanzando en conjunto con todos los compañeros.
-Estructura en capas con el siguiente patrón: Modelo-Vista-Controlador (MVC)
-Uso de arreglos de objetos e instancias estáticas simulando una base de datos en memoria
Paso 5:Desarrollo de interfaz gráfica (GUI)
-Implementación de pantallas de login, menú principal y vistas para reservas, huéspedes y habitaciones.
Paso 6:Pruebas del sistema
-Pruebas funcionales por cada requerimiento:creación de reservas,check in .check out,etc.
-Captura y validación de resultados
Paso 7:Documentación del proyecto
-Redacción del informe final incluyendo diagramas de clases,diagrama de casos de uso, metodología, objetivos SMART, conclusiones, etc.
                




      4.  EL PROBLEMA
Para el análisis de manera estructurada de la situación que enfrenta el hotel ,se emplea la técnica de Árbol de Problemas,una herramienta que nos permite identificar de forma visual y organizada el problema central, sus causas y efectos.
Antes de presentar el diagrama, se describirán las principales causas que originan esta problemática y sus efectos respectivamente, que hemos identificado. Al final mostraremos el árbol de problemas completo que resume la relación de estos elementos.
4.1 Problema Principal:
El hotel presenta una gestión ineficiente y desorganizada de las reservas, huéspedes, habitaciones y servicios adicionales. Todo debido principalmente a que los procesos se realizan de manera manual o con herramientas poco adecuadas, lo que genera errores frecuentes en el servicio, pérdida de información y dificultades en las actividades diarias.
4.2 Causas Principales :
1.Gestión manual o desactualizada de la información.
-El uso de registros en papel,archivos dispersos o Excel ,también genera información duplicada o incompleta y con riesgo de pérdida o inconsistencia de datos.
2.Ausencia de control automatizado de la disponibilidad de las habitaciones
-No existe un sistema que determine el estado de la habitación de manera automática(Disponible,Ocupada,En Limpieza),también hay una problema con la validación de las fechas de reserva y también puede ocurrir una doble asignación(overbooking).
3.Falta de autenticación y control por roles.
-No se diferencian funciones entre el administrador y recepcionista asi tambien como cambios no autorizados o imposibles de rastrear.
4.Procesos operativos lentos y con alta probabilidad de error.
-El registro manual de huéspedes, reservas y servicios, así como el cálculo manual de costos, incrementan la probabilidad de equivocaciones y retrasos en la atención.
5.Falta de trazabilidad en las operaciones del hotel.
-No se registra quién realizó cada acción, lo que impide auditar modificaciones, supervisar al personal y corregir errores oportunamente.
4.3Efectos del problema
1.Overbooking.
-La misma habitación puede ser asignada a dos huéspedes por falta de control automático, generando conflictos y mala atención.
2.Errores en la facturación.
-Los costos de noches y servicios adicionales pueden calcularse incorrectamente debido a procedimientos manuales.
3.Mala experiencia del huésped.
-Los tiempos de espera aumentan y se producen fallas en la asignación de habitaciones esto provoca la reducción de satisfacción del cliente con respecto al servicio,
4.Sobrecarga de trabajo para el personal.
-Genera un doble registro de información ,esto provoca la correcciones instantáneas y causa procesos repetitivos e ineficientes.
5.Pérdidas económicas.
-Los errores operativos generan reembolsos, mala reputación y menor fidelización, afectando directamente los ingresos.


















4.4 Diagrama de Árbol de Problemas.
La plataforma utilizada para realizar el diagrama de Árbol de Problemas fue Canva ,con la información resumida que pedimos a la Inteligencia Artificial con el siguiente prompt:
PROMPT UTILIZADO:"Necesito que organices y resumas información para construir un Árbol de Problemas de un sistema de gestión de reservas para un hotel.El problema principal identificado es: Gestión ineficiente de reservas, huéspedes y habitaciones.
Hemos identificado las siguientes causas y sus efectos:
-Gestión manual o desactualizada de la información: Overbooking.
-Falta de control automático de la disponibilidad de habitaciones: Errores en la facturación.
-Ausencia de autenticación y roles definidos: Mala experiencia del huésped.
-Procesos operativos lentos y propensos a errores: Sobrecarga de trabajo para el personal.
-Falta de trazabilidad en las operaciones: Pérdidas económicas para el hotel.
Con esta información, por favor genera un resumen claro, coherente y adecuado para ser colocado en un diagrama de Árbol de Problemas, agrupando las causas debajo del problema central y los efectos arriba. El contenido debe ser conciso y apto para pegar directamente en una plantilla de Canva.”  














      5.  OBJETIVOS (SMART)
Para garantizar que el desarrollo del sistema sea claro, medible y verificable, se utilizará la metodología SMART, la cual permite definir objetivos que sean Específicos (S), Medibles (M), Alcanzables (A), Relevantes (R) y Limitados en el Tiempo (T).
Esta estructura facilita planificar el proyecto de manera ordenada, evaluar los avances y posteriormente verificar si cada objetivo fue cumplido en las conclusiones.
A continuación, se presentan los objetivos del sistema formulados bajo este enfoque.
OBJETIVO SMART 1 – Gestión de entidades
Desarrollar un módulo para registrar, modificar y eliminar huéspedes, habitaciones, servicios adicionales y usuarios.
S – Específico:Implementar el CRUD completo para las principales entidades del sistema.
M – Medible:Debe permitir gestionar al menos cuatro tipos de entidades: Huésped, Habitación, Servicio y Usuario.
A – Alcanzable:Se basa en conceptos de POO estudiados (clases, herencia, arreglos).
R – Relevante:Es fundamental para la administración de la información del hotel.
T – Tiempo:Debe completarse durante la fase principal de desarrollo del proyecto.
OBJETIVO SMART 2 – Validación y creación de reservas
Implementar un sistema de reservas que valide disponibilidad según fechas de inicio y fin.
S – Específico:Verificar estado de habitación y evitar conflictos de fechas.
M – Medible:El sistema debe gestionar correctamente la reserva y evitar errores como el overbooking.
A – Alcanzable:Utiliza estructuras y métodos que ya existen en el modelo del sistema.
R – Relevante:Asegura una correcta asignación de habitaciones, clave para la operación del hotel.
T – Tiempo:Debe implementarse dentro del ciclo de desarrollo del proyecto.


OBJETIVO SMART 3 – Gestión de estadías (Check-in / Check-out / Consumos)
Permitir registrar check-in, check-out y consumos adicionales durante la estadía del huésped.
S – Específico:Cambiar el estado de habitaciones y añadir consumos adicionales.
M – Medible:Debe registrar correctamente los consumos y el estado de la habitación en cada operación.
A – Alcanzable:Se apoya en las clases reserva, habitación y servicios.
R – Relevante:Automatiza procesos clave del recepcionista.
T – Tiempo:Debe integrarse antes de la etapa final del proyecto.


OBJETIVO SMART 4 – Facturación automática
Calcular automáticamente el costo total de la estadía sumando noches y consumos.
S – Específico:Implementar un cálculo automático en el proceso de check-out.
M – Medible:Cada factura debe emitirse sin errores de cálculo.
A – Alcanzable:Requiere operaciones básicas sobre los datos registrados.
R – Relevante:Reduce errores en facturas y mejora la transparencia con el cliente.
T – Tiempo:Debe implementarse en la fase final del desarrollo del sistema.
OBJETIVO SMART 5 – Interfaz gráfica del sistema
Desarrollar una interfaz gráfica intuitiva que permita a administradores y recepcionistas utilizar el sistema según su rol.
S – Específico:Crear pantallas de login, menú principal y gestión de entidades.
M – Medible:Cada funcionalidad debe ser accesible mediante una serie de pasos clara y simple.
A – Alcanzable:Utiliza herramientas de GUI vistas en clase (Swing/NetBeans).
R – Relevante:Facilita la interacción del usuario con el sistema.
T – Tiempo:Debe finalizarse antes de la presentación del proyecto.




      6. CAPÍTULO III: DESARROLLO DEL SISTEMA
      1. Diagrama de Clases
El diagrama de clases es una representación estructural del sistema que permite visualizar sus entidades principales, sus características, sus comportamientos y las relaciones entre ellas.
Para construirlo, se realizó un proceso previo de análisis que permitió identificar los         elementos del dominio, organizarlos y transformarlos en clases UML.
A continuación, se presenta el procedimiento seguido y el desarrollo de cada una de sus etapas.
PROCEDIMIENTO PARA EL DIAGRAMA DE CLASES (CON DESARROLLO)
1. Análisis del problema y del contexto
Antes de diseñar el modelo, se revisó cómo funciona un hotel en sus procesos principales:
-registro de huéspedes,
-reservas,
-check-in,
-check-out,
-asignación de habitaciones,
-gestión de servicios adicionales,
-uso de roles de sistema (administrador y recepcionista).
2. Identificación de objetos del sistema
En esta etapa se identificaron todos los elementos importantes que intervienen en el sistema, sin clasificarlos aún.
-Huésped
-Recepcionista
-Administrador
-Usuario
-Habitación
-Reserva
-Servicio adicional
-Check-in
-Check-out
-Fecha de inicio
-Fecha de fin
-Estado de habitación
-Tipo de habitación
-Precio
-DNI / documento
-Nombres
-Apellidos
-Teléfono
-Correo
-Login
-Autenticación
-Registro de huéspedes
-Registro de habitaciones
-Registro de reservas
-Registro de servicios
-Interfaz gráfica
-Menú del sistema
-Sesión de usuario
3. Listado de objetos del sistema
Se organizó la lista anterior para agrupar objetos similares según su naturaleza.
Personas
-Huésped
-Recepcionista
-Administrador
-Usuario
-Nombres
-Apellidos
-DNI
-Teléfono
-Correo
Habitaciones
-Habitación
-Número
-Capacidad máxima
-Estado
-Tipo
-Precio por noche
Reservas
-Reserva
-Fecha de inicio
-Fecha de fin
-Check-in
-Check-out
Servicios
-Servicio adicional
-Precio del servicio
-Tipo de servicio
Sistema
-Login
-Autenticación
-Registros
-Interfaz gráfica
-Menú del sistema
-Sesión
3. Listado de objetos del sistema
Se organizó la lista anterior para agrupar objetos similares según su naturaleza.
Personas
-Huésped
-Recepcionista
-Administrador
-Usuario
-Nombres
-Apellidos
-DNI
-Teléfono
-Correo
Habitaciones
-Habitación
-Número
-Capacidad máxima
-Estado
-Tipo
-Precio por noche
Reservas
-Reserva
-Fecha de inicio
-Fecha de fin
-Check-in
-Check-out
Servicios
-Servicio adicional
-Precio del servicio
-Tipo de servicio
Sistema
-Login
-Autenticación
-Registros
-Interfaz gráfica
-Menú del sistema
-Sesión
4. Clasificación de objetos (Clases, Atributos, Métodos, Actores)
Clases del sistema
-Usuario (abstracta)
-Administrador
-Recepcionista
-Huesped
-Habitacion
-Reserva
-ServiciosAdicionales
-BaseDeDatos
-ControladorMain
Atributos
-nombre_usuario
-clave
-tipo_usuario
-dni
-telefono
-nombres
-apellidos
-correo
-numero
-capacidadMaxima
-precioPorNoche
-tipoHabitacion
-estadoHabitacion
-fechaInicio
-fechaFin
-checkIn
Métodos
-registrarHuesped()
-eliminarHuesped()
-crearHabitacion()
-eliminarHabitacion()
-registrarServicioAdicional()
-validarLogin()
-autenticarUsuario()
-checkIn()
-checkOut()
Actores
-Administrador
-Recepcionista
5. Transformación en clases UML
Ahora le pedimos a la IA que todas nuestras clases ,métodos y atributos identificados y que nos pase en formato de plantUML.
PROMPT UTILIZADO:Necesito que transformes las clases, atributos y métodos identificados de mi sistema de gestión de reservas de hotel en un diagrama de clases UML en formato PlantUML.
Las clases identificadas son: Usuario (abstracta), Administrador, Recepcionista, Huesped, Habitacion, Reserva, ServiciosAdicionales, BaseDeDatos y ControladorMain.
Los atributos identificados son: nombre_usuario, clave, tipo_usuario, dni, telefono, nombres, apellidos, correo, numero, capacidadMaxima, precioPorNoche, tipoHabitacion, estadoHabitacion, fechaInicio, fechaFin y checkIn.
Los métodos identificados son: registrarHuesped(), eliminarHuesped(), crearHabitacion(), eliminarHabitacion(), registrarServicioAdicional(), validarLogin(), autenticarUsuario(), checkIn() y checkOut().
Por favor, genera un diagrama de clases UML completo en PlantUML usando estos elementos y mostrando las relaciones entre clases, incluyendo herencia, asociaciones y agregaciones.”
Construcción del diagrama de clases UML
Finalmente, se representaron gráficamente las clases con:
-atributos,
-métodos,
-herencia entre Usuario → Admin / Recepcionista,
-asociaciones entre Reserva → Huesped y Habitacion,
-agregación entre BaseDeDatos → listas de objetos.
Diagrama de clases con plantUML:
Codigo plantUML:
@startuml
!theme spacelab


title Diagrama de Clases Completo del Sistema


package "Modelo" {
    package "Entidad" {
        class huesped {
            -dni: int
            -nombres: String
        }


        class serviciosAdicionales {
            -nombre: String
            -precio: double
        }


        class habitacion {
            -numero: int
            -precioPorNoche: double
            -tipo: String
            -estado: estado_habitacion
        }


        enum estado_habitacion {
            Disponible
            Ocupada
            Reservada
            En_Limpieza
        }
        
        enum tipo_habitacion {
        }


        class reserva {
            -fechaInicio: LocalDate
            -fechaFin: LocalDate
            -checkIn: boolean
            +calcularCostoTotal(): double
            +agregarServicioAdicional(servicio): void
        }
    }


    package "Usuario" {
        abstract class usuario {
            #nombre_usuario: String
            #clave: String
            #tipo: tipo_usuario
        }


        class admin extends usuario {
        }


        class recepcionista extends usuario {
        }


        enum tipo_usuario {
            ADMINISTRADOR
            RECEPCIONISTA
        }
    }
}


package "Controlador" {
    class ControladorMain {
        -db: baseDeDatos
        +autenticarUsuario(user, pass): usuario
    }


    class baseDeDatos {
        -lista_huespedes: ArrayList<huesped>
        -reservas: ArrayList<reserva>
        -habitaciones: ArrayList<habitacion>
        -lista_admins: ArrayList<admin>
        -lista_recepcionistas: ArrayList<recepcionista>
        +getReservaActivaPorHabitacion(numHabitacion): reserva
        +buscarReservaPorDniHuesped(dni): reserva
        +validarLogin(user, pass): usuario
    }
}


package "Vista" {
    package "Paneles Principales" {
        class app {
        }
        class Login {
            -controlador: ControladorMain
        }
        class MenuAdmin extends JFrame {
            -controlador: ControladorMain
        }
        class MenuRecepcionista extends JFrame {
             -controlador: ControladorMain
        }
    }


    package "Paneles Secundarios" {
        class agregar_empleado extends JFrame {
            -controlador: ControladorMain
        }
        class check_in extends JFrame {
            -controlador: ControladorMain
        }
        class check_out extends JFrame {
            -controlador: ControladorMain
        }
        class crear_reserva extends JFrame {
            -controlador: ControladorMain
        }
        class modificar_empleado extends JFrame {
            -controlador: ControladorMain
        }
        class modificar_reserva extends JFrame {
            -controlador: ControladorMain
        }
    }
}




' --- Relaciones ---


' Controlador y Base de Datos
ControladorMain *-- "1" baseDeDatos : contiene


' Base de Datos y Modelo (Composición)
baseDeDatos -- "" huesped
baseDeDatos -- "" reserva
baseDeDatos -- "" habitacion
baseDeDatos -- "" serviciosAdicionales
baseDeDatos -- "" admin
baseDeDatos -- "" recepcionista


' Relaciones entre Entidades
reserva -- "1" huesped
reserva -- "1" habitacion
reserva o-- "*" serviciosAdicionales
habitacion -- "1" estado_habitacion


' Relaciones de Herencia de Usuario
usuario <|-- admin
usuario <|-- recepcionista
usuario -- "1" tipo_usuario


' Dependencias de la Vista con el Controlador
app ..> ControladorMain
Login ..> ControladorMain
MenuAdmin ..> ControladorMain
MenuRecepcionista ..> ControladorMain
agregar_empleado ..> ControladorMain
check_in ..> ControladorMain
check_out ..> ControladorMain
crear_reserva ..> ControladorMain
modificar_empleado ..> ControladorMain
modificar_reserva ..> ControladorMain


@enduml
Diagrama de clases:
  


















      2. Diagrama de Casos de Uso:
6.2.1 Identificación de actores:
Identificamos tres actores principales que interactúan con el sistema:
- Cliente: El usuario final que busca y realiza reservas.
- Recepcionista: El personal del hotel que gestiona las operaciones diarias, como el check-in, check-out y las reservas existentes.
- Administrador: El personal con permisos para configurar el sistema, gestionar usuarios y generar informes.
6.2.2 Casos de uso:
- Cliente:
El cliente no interactúa directamente con el software, pero las acciones quiere realizar implican el uso del software, por lo cual contacta al recepcionista o administrador
Caso de uso
	Descripción
	Reserva
	El cliente desea reservar una habitación del hotel
	Check-In
	El cliente desea ingresar al hotel y comenzar su estadía
	Check-Out
	El cliente finaliza su estadía
	

- Recepcionista:
El recepcionista es el puente entre el cliente y el software, es decir, es quien gestiona las reservas y administra los estados de las habitaciones.
Caso de uso
	Descripción
	Gestionar reservas
	El recepcionista crea y modifica reservas
	Administrar información de las habitaciones
	El recepcionista desea consultar qué habitaciones están disponibles
	Realizar el Check-In/Check-Out
	El recepcionista realiza el Check-In/Check.Out a pedido del cliente
	

- Administrador:
El administrador tiene las mismas opciones que un recepcionista, además de la capacidad de crear y modificar empleados en el sistema
Caso de uso
	Descripción
	Usos de recepcionista
	El administrador tiene todas las capacidades de un recepcionista
	Crear y administrar empleados
	El administrador puede crear y administrar credenciales de recepcionistas
	

6.2.3 Diagrama de casos de uso:
  


      3. Pruebas (calidad de software)        






      7. Conclusiones y aprendizajes:

1. Se cumplió con el objetivo principal del proyecto al desarrollar un sistema de información funcional para la gestión de reservas y estadías de un hotel, aplicando de manera exitosa los conceptos fundamentales de la Programación Orientada a Objetos (POO) y la arquitectura Modelo-Vista-Controlador (MVC).

2. La implementación de la herencia (ej. clase `Usuario` con `Admin` y `Recepcionista`) y el polimorfismo permitió crear una estructura de código organizada, reutilizable y fácil de mantener, donde las responsabilidades de cada rol están claramente definidas y segregadas.

3. El uso de arreglos de objetos en memoria (en la clase `baseDeDatos`) fue una estrategia efectiva para simular el comportamiento de una base de datos y cumplir con los requisitos del curso, permitiendo realizar operaciones CRUD (Crear, Registrar, Actualizar, Eliminar) de forma coherente sobre las entidades principales del sistema (huéspedes, habitaciones, reservas, etc.).

4. Se lograron todos los objetivos SMART planteados, desde la gestión de entidades y la validación de reservas para evitar el `overbooking`, hasta la automatización del check-in/check-out y el cálculo de la facturación, demostrando la viabilidad y utilidad del sistema para resolver el problema de la gestión manual.

5. El desarrollo de una interfaz gráfica (GUI) con Swing, aunque básica, demostró ser fundamental para facilitar la interacción del personal del hotel con el sistema, mejorando la eficiencia y reduciendo la probabilidad de errores en comparación con los procesos manuales. El aprendizaje clave fue la importancia de separar la lógica de negocio (Modelo/Controlador) de la presentación (Vista) para la escalabilidad del software.

      8. Recomendaciones:

1. **Implementar persistencia de datos:** Para que el sistema sea viable en un entorno de producción real, se recomienda reemplazar los arreglos en memoria por una base de datos persistente (como MySQL, PostgreSQL o SQLite). Esto garantizará que la información no se pierda al cerrar la aplicación y permitirá manejar un volumen de datos mucho mayor.

2. **Desarrollar una interfaz web o API REST:** Para expandir el alcance del sistema, se podría desarrollar un portal web que permita a los clientes finales consultar disponibilidad y realizar reservas directamente. Alternativamente, crear una API REST permitiría que el sistema se integre con otras plataformas de reserva en línea (OTAs).

3. **Mejorar la seguridad:** Se recomienda implementar un sistema de encriptación para las contraseñas de los usuarios almacenadas en el sistema, utilizando algoritmos de hashing como SHA-256 o BCrypt, en lugar de guardarlas como texto plano.

4. **Expandir el módulo de reportes:** El sistema podría enriquecerse con un módulo de reportería más avanzado, que incluya gráficos y métricas visuales sobre la ocupación, ingresos por tipo de habitación, temporadas de mayor demanda y otros indicadores clave de rendimiento (KPIs) para la toma de decisiones gerenciales.

5. **Refinamiento de la Interfaz de Usuario (UI/UX):** Se podría realizar una modernización de la interfaz gráfica, utilizando librerías más actuales como JavaFX o migrando a un framework de desarrollo de escritorio para ofrecer una experiencia de usuario (UX) más rica e intuitiva.




      9. Bibliografía:
      1. Código Fuente del Programa:
  

  

  
def linea_mayor_recaudacion(matriz):
    print("       L I N E A  C O N  M A Y O R  R E C A U D A C I Ó N")
    print("-----------------------------------------------------------------")
    lineas = len(matriz[0])
    suma_lineas = [0] * lineas
    
    for fila in matriz:
        for j in range(lineas):
            suma_lineas[j] += fila[j]
            
    mayor = suma_lineas[0]
    for total in suma_lineas:
        if total > mayor:
            mayor = total


    lineas_max = []
    for i in range(len(suma_lineas)):
        if suma_lineas[i] == mayor:
            lineas_max.append(i+1)
            
    print(f"Líneas con mayor recaudación total ({mayor} soles): {lineas_max}")


def linea_menor_recaudacion(matriz):
    print("       L I N E A  C O N  M E N O R  R E C A U D A C I Ó N")
    print("-----------------------------------------------------------------")
    for i in range(len(matriz)):
        fila = matriz[i]
        menor = fila[0]
        for valor in fila:
            if valor < menor:
                menor = valor


        lineas_min = []
        for j in range(len(fila)):
            if fila[j] == menor:
                lineas_min.append(j+1)


        print(f" Bus {i+1}: Línea(s) {lineas_min} con {menor} soles")


def bubble_sort(lista):
    for i in range(len(lista) - 1):
           for j in range(len(lista) - 1 - i):
               if(lista[j] > lista[j + 1]):
                   aux = lista[j + 1]
                   lista[j + 1] = lista[j] 
                   lista[j] = aux
    return lista
  
def ordenar_recaudacion(matriz):
    print("Recaudaciones ordenadas de menor a mayor de cada bus")
    for i in range(len(matriz)):
        bubble_sort(matriz[i])
        print(f"Bus {i+1}: {matriz[i]}")


def intercambio_recaudaciones(matriz):
    
    print("    I N T E R C A M B I O  D E  R E C A U D A C I O N E S")
    print("-----------------------------------------------------------------")    


    num_buses = len(matriz)
    num_lineas = len(matriz[0])
    
    bus1 = int(input(f"Ingrese el número del primer bus (1-{num_buses}): "))
    while bus1 < 1 or bus1 > num_buses:
        print("Número de bus fuera de rango. Intente nuevamente.")
        bus1 = int(input(f"Ingrese el número del primer bus (1-{num_buses}): "))


    bus2 = int(input(f"Ingrese el número del segundo bus (1-{num_buses}): "))
    while bus2 < 1 or bus2 > num_buses:
        print("Número de bus fuera de rango. Intente nuevamente.")
        bus2 = int(input(f"Ingrese el número del segundo bus (1-{num_buses}): "))


    linea = int(input(f"Ingrese el número de la línea (1-{num_lineas}): "))
    while linea < 1 or linea > num_lineas:
        print("Número de línea fuera de rango. Intente nuevamente.")
        linea = int(input(f"Ingrese el número de la línea (1-{num_lineas}): "))
    
    valor1 = matriz[bus1 - 1][linea - 1]
    matriz[bus1 - 1][linea - 1] = matriz[bus2 - 1][linea -1]
    matriz[bus2 - 1][linea -1] = valor1
    
    print("Se intercambiaron la recaudacion de los buses")
    print(f"Bus {bus1}: {matriz[bus1 - 1]}")
    print(f"Bus {bus2}: {matriz[bus2 - 1]}")




















  
   def main():  
    
    buses, lineas = 0, 0
    matriz = []
    opcion = 0
    
    while opcion != 9:
        print(" ")
        print("---------------------------- M E N Ú ----------------------------")
        print(" ")
        print("1: Identificacion de datos")
        print("2: Generacion de recaudaciones")
        print("3: Buscar bus(es) con mayor recaudación")
        print("4: Línea(s) con mayor recaudación total")
        print("5: Línea con menor recaudación por bus")
        print("6: Ordenar las recaudaciones")
        print("7: Intercambiar recaudaciones de buses")
        print("8: Mostrar matriz")
        print("9: Salir del programa")
        print("-----------------------------------------------------------------")
        opcion = int(input("Ingrese alguna opcion: "))
        print("-----------------------------------------------------------------")
    
        
        if opcion == 1:
            buses, lineas = identificacion_de_datos()
        elif opcion == 2:
            if buses == 0 or lineas == 0:
                print("Primero debe ingresar la cantidad de buses y líneas (opción1).")
            else:
                print("            M A T R I Z  D E  R E C A U D A C I Ó N")                      
                      print("-----------------------------------------------------------------")
                matriz = generar_recaudaciones(buses, lineas)
                imprimir_matriz(matriz)
        elif opcion == 3:
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                buscar_mayor_recaudacion(matriz)
        elif opcion == 4:
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                linea_mayor_recaudacion(matriz)
        elif opcion == 5:
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                linea_menor_recaudacion(matriz)
        elif opcion == 6:
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                print("               O R D E N A N D O  L A  M A T R I Z")
                print("-----------------------------------------------------------------")
                ordenar_recaudacion(matriz)
        elif opcion == 7:
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                intercambio_recaudaciones(matriz)
        elif opcion == 8        :
            if not matriz:
                print("Primero genere la matriz (opción 2).")
            else:
                print("             M A T R I Z  A C T U A L I Z A D A")
                print("-----------------------------------------------------------------")
                imprimir_matriz(matriz)
        elif opcion == 9:
            print("Programa finalizado. Vuelva pronto :)")
        else:
            print("Opción inválida. Ingrese alguna opción válida, por favor.")


       main()






      2. Ejecución del Programa y Resultados de las Funcionalidades: Figura 5.2.1.
Menú principal del programa
  





Figura 5.2.2.
Ingreso del número de buses y líneas
  

Figura 5.2.3.
Matriz de recaudación:
  
  



Figura 5.2.4.
Bus con mayor recaudación en total de la empresa:
  



Figura 5.2.5.
Linea con mayor recacudacion total
  

Figura 5.2.6.
Línea con menor recaudación por bus
  





Figura 5.2.7.  
Ordenar las recaudaciones
  



Figura 5.2.8.
Intercambiar recaudaciones de buses
  

Figura 5.2.9.
Mostrar matriz
  



Figura 5.2.10.  
Salir del programa
  

  
COEVALUACIÓN GRUPAL:


GRUPO:
11
	APELLIDOS Y NOMBRES
	COEVALUACIÓN
	Abanto Lozano, Gilmer Alonso
	100%
	Arista Llanquecha, Piero Aarón
	100%
	Madalengoitia Paredes,Felipe
	100%